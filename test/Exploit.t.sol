// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/Challenge.sol";
import "../src/Exploit.sol";
import "../src/Diamond.sol";
import "../src/HexensCoin.sol";
import "../src/Vault.sol";

contract ExploitTest is Test {
    Challenge public challenge;
    Exploit public exploit;
    address public player = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;
    Diamond public diamond;
    HexensCoin public hexensCoin;
    Vault public vault;

    function setUp() public {
        // Setup player
        vm.deal(player, 100 ether);
        
        // Deploy the challenge
        challenge = new Challenge(player);
        
        // Get contract instances
        diamond = challenge.diamond();
        hexensCoin = challenge.hexensCoin();
        vault = challenge.vault();
        
        // Deploy the exploit contract
        vm.startPrank(player);
        exploit = new Exploit(challenge);
        vm.stopPrank();
    }

    function testInitialState() public {
        console.log("\nChecking initial state:");
        console.log("Vault diamond balance:", diamond.balanceOf(address(vault)));
        console.log("Player diamond balance:", diamond.balanceOf(player));
        
        assertEq(diamond.balanceOf(address(vault)), challenge.DIAMONDS(), "Vault should have all diamonds initially");
        assertEq(diamond.balanceOf(player), 0, "Player should have no diamonds initially");
        assertFalse(challenge.isSolved(), "Challenge should not be solved initially");
    }

    function testBurnExecution() public {
        vm.startPrank(player);
        
        console.log("\nBefore burn:");
        console.log("Vault diamond balance:", diamond.balanceOf(address(vault)));
        
        // Execute exploit
        exploit.executeExploit();
        
        console.log("\nAfter burn:");
        console.log("Vault diamond balance:", diamond.balanceOf(address(vault)));
        console.log("Player diamond balance:", diamond.balanceOf(player));
        
        assertEq(diamond.balanceOf(address(vault)), 0, "Vault should have no diamonds after burn");
        vm.stopPrank();
    }

    function testExploit() public {
        console.log("\nStarting exploit:");
        console.log("Initial vault diamond balance:", diamond.balanceOf(address(vault)));
        console.log("Initial player diamond balance:", diamond.balanceOf(player));
        
        vm.startPrank(player);
        exploit.executeExploit();
        vm.stopPrank();

        console.log("\nAfter exploit:");
        console.log("Final vault diamond balance:", diamond.balanceOf(address(vault)));
        console.log("Final player diamond balance:", diamond.balanceOf(player));
        console.log("Challenge solved:", challenge.isSolved());

        assertTrue(challenge.isSolved(), "Challenge should be solved");
        assertEq(diamond.balanceOf(player), challenge.DIAMONDS(), "Player should have all diamonds");
        assertEq(diamond.balanceOf(address(vault)), 0, "Vault should have no diamonds");
    }

    function testExploitWithoutPlayer() public {
        // This should fail
        vm.startPrank(address(0x1234));
        vm.expectRevert("Only player can execute");
        exploit.executeExploit();
        vm.stopPrank();
    }

    function testExploitAsPlayer() public {
        // This should succeed
        vm.startPrank(player);
        exploit.executeExploit();
        vm.stopPrank();
        
        assertTrue(challenge.isSolved(), "Challenge should be solved");
    }
}